{"ast":null,"code":"export function AI2(playerState, turn) {\n  var pos;\n  var max = 0;\n  var max_position;\n  var table = document.getElementById('Team 1 turn');\n  var cells = table.getElementsByClassName('image1'); // Pick the cell with highest prob\n\n  for (var i = 0; i < 100; i++) {\n    if (max < playerState.positions[i].probability) {\n      max = playerState.positions[i].probability;\n      max_position = i;\n    }\n  } // If there is no such cell\n\n\n  if (max === 0) {\n    // Randomly pick one\n    if (turn == \"Team 2 turn\") {\n      do {\n        pos = Math.floor(Math.random() * 100);\n      } while (playerState.positions[pos].fired);\n\n      max_position = pos;\n    }\n  }\n\n  console.log('AI team 2 ' + max_position);\n\n  if (max_position >= 0) {\n    cells[max_position].click();\n  }\n\n  playerState.positions[max_position].probability = -1;\n  calculateNextPos(playerState, max_position);\n}\n_c = AI2;\n\nfunction calculateNextPos(playerState, current_position) {\n  var randomness = 2;\n  var directions = {\n    'w': null,\n    'n': null,\n    'e': null,\n    's': null\n  };\n  var oppositeDirection;\n  var currentCell = playerState.positions[current_position]; // If click on ship\n\n  if (currentCell.hit) {\n    // Calculate adjacent cell's probability\n    for (var direction in directions) {\n      var adjacent = currentCell[direction];\n      var streak = 1;\n\n      switch (direction) {\n        case 'w':\n          oppositeDirection = 'e';\n          break;\n\n        case 'e':\n          oppositeDirection = 'w';\n          break;\n\n        case 'n':\n          oppositeDirection = 's';\n          break;\n\n        case 's':\n          oppositeDirection = 'n';\n          break;\n      } // If the adjacent cell has never been picked\n\n\n      if (adjacent && adjacent.probability >= 0) {\n        /*\r\n        Check the next 2 cells with same alignment\r\n            → If both of them is hit but still not sunk \r\n                → likely to be the same ship\r\n                    → should pick in the same alignment → more likely to hit\r\n                        → give more probability to adjacent cell\r\n            [ ] [ ] [ ]\r\n          [X] [X] [ ] ← Should pick here\r\n          [ ] [ ] [ ]\r\n        \r\n        */\n        var checker1 = adjacent[oppositeDirection];\n        var checker2 = checker1[oppositeDirection];\n\n        if (checker1) {\n          while (checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk) {\n            streak += 1;\n            checker1 = checker1[oppositeDirection];\n            checker2 = checker2[oppositeDirection];\n          }\n        }\n\n        var random = Math.floor(50 * (Math.random() * (randomness - 1) + 1));\n        adjacent.probability += streak * random;\n      } // If the adjacent cell is out of map and the next 2 cell with same alignment is hit and not sunk, the next pick should be the first unpicked cell on the opposite side\n      else if (adjacent === null) {\n        var checker1 = currentCell;\n        var checker2 = checker1[oppositeDirection];\n\n        if (checker1) {\n          while (checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk) {\n            streak += 1;\n            checker1 = checker1[oppositeDirection];\n            checker2 = checker2[oppositeDirection];\n          }\n        }\n\n        if (checker2 && checker2.probability >= 0) {\n          checker2.probability *= streak;\n        }\n      }\n    }\n  } // If not click on ship\n  else if (currentCell.fired) {\n    for (var direction in directions) {\n      var adjacent = currentCell[direction];\n      var streak = 1;\n\n      switch (direction) {\n        case 'w':\n          oppositeDirection = 'e';\n          break;\n\n        case 'e':\n          oppositeDirection = 'w';\n          break;\n\n        case 'n':\n          oppositeDirection = 's';\n          break;\n\n        case 's':\n          oppositeDirection = 'n';\n          break;\n      }\n      /*\r\n      If adjacent cell is not sunk\r\n          → the other part of the ship must be on the other side\r\n              -> give the other side unpicked cell (that isn't out of the map) the highest probability\r\n                                   [ ] [ ] [ ] [ ]\r\n           Ship should be here → [ ] [X] [X] [M] ← Miss the ship here\r\n                                 [ ] [ ] [ ] [ ]\r\n      */\n\n\n      if (adjacent && adjacent.hit && !adjacent.sunk) {\n        var checker1 = adjacent;\n\n        while (checker1 && checker1.hit && !checker1.sunk) {\n          streak += 1;\n          checker1 = checker1[direction];\n        }\n\n        if (checker1 && checker1.probability >= 0) {\n          checker1.probability *= streak;\n        }\n      }\n      /*\r\n      But if it sunk\r\n          -> We should try pick randomly more than pick next to the sunk ship because the ship more likely to spread out more than stick together\r\n      */\n      else if (currentCell[direction] && currentCell[direction].sunk && currentCell[oppositeDirection] && (!currentCell[oppositeDirection].fired || !currentCell[oppositeDirection].hit)) {\n        for (var i = 0; i < 100; i++) {\n          if (playerState.positions[i].probability > 0) {\n            playerState.positions[i].probability = 0;\n          }\n        }\n      }\n    }\n  }\n\n  console.log(\"\");\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"AI2\");","map":{"version":3,"sources":["F:/Code/Project/AI-project/battleship/src/AI/AI_team2.js"],"names":["AI2","playerState","turn","pos","max","max_position","table","document","getElementById","cells","getElementsByClassName","i","positions","probability","Math","floor","random","fired","console","log","click","calculateNextPos","current_position","randomness","directions","oppositeDirection","currentCell","hit","direction","adjacent","streak","checker1","checker2","sunk"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,WAAb,EAA0BC,IAA1B,EAAgC;AACnC,MAAIC,GAAJ;AACA,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIC,YAAJ;AACA,MAAIC,KAAK,GAAGC,QAAQ,CAACC,cAAT,CAAwB,aAAxB,CAAZ;AACA,MAAIC,KAAK,GAAGH,KAAK,CAACI,sBAAN,CAA6B,QAA7B,CAAZ,CALmC,CAOnC;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,GAAnB,EAAwBA,CAAC,EAAzB,EAA6B;AACzB,QAAIP,GAAG,GAAGH,WAAW,CAACW,SAAZ,CAAsBD,CAAtB,EAAyBE,WAAnC,EAAgD;AAC5CT,MAAAA,GAAG,GAAGH,WAAW,CAACW,SAAZ,CAAsBD,CAAtB,EAAyBE,WAA/B;AACAR,MAAAA,YAAY,GAAGM,CAAf;AACH;AACJ,GAbkC,CAenC;;;AACA,MAAGP,GAAG,KAAK,CAAX,EACA;AACI;AACA,QAAGF,IAAI,IAAI,aAAX,EACA;AACI,SAAG;AACCC,QAAAA,GAAG,GAAGW,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,GAA3B,CAAN;AACH,OAFD,QAESf,WAAW,CAACW,SAAZ,CAAsBT,GAAtB,EAA2Bc,KAFpC;;AAGAZ,MAAAA,YAAY,GAAGF,GAAf;AACH;AAEJ;;AACDe,EAAAA,OAAO,CAACC,GAAR,CAAY,eAAed,YAA3B;;AAEA,MAAGA,YAAY,IAAI,CAAnB,EAAsB;AAClBI,IAAAA,KAAK,CAACJ,YAAD,CAAL,CAAoBe,KAApB;AACH;;AAEDnB,EAAAA,WAAW,CAACW,SAAZ,CAAsBP,YAAtB,EAAoCQ,WAApC,GAAkD,CAAC,CAAnD;AACAQ,EAAAA,gBAAgB,CAACpB,WAAD,EAAcI,YAAd,CAAhB;AACH;KApCeL,G;;AAsChB,SAASqB,gBAAT,CAA0BpB,WAA1B,EAAuCqB,gBAAvC,EAAyD;AACrD,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAIC,UAAU,GAAG;AAAE,SAAK,IAAP;AAAa,SAAK,IAAlB;AAAwB,SAAK,IAA7B;AAAmC,SAAK;AAAxC,GAAjB;AACA,MAAIC,iBAAJ;AACA,MAAIC,WAAW,GAAGzB,WAAW,CAACW,SAAZ,CAAsBU,gBAAtB,CAAlB,CAJqD,CAMrD;;AACA,MAAGI,WAAW,CAACC,GAAf,EAAoB;AAChB;AACA,SAAI,IAAIC,SAAR,IAAqBJ,UAArB,EAAiC;AAC7B,UAAIK,QAAQ,GAAGH,WAAW,CAACE,SAAD,CAA1B;AACA,UAAIE,MAAM,GAAG,CAAb;;AAEA,cAAOF,SAAP;AAEI,aAAK,GAAL;AACIH,UAAAA,iBAAiB,GAAG,GAApB;AACA;;AACJ,aAAK,GAAL;AACIA,UAAAA,iBAAiB,GAAG,GAApB;AACA;;AACJ,aAAK,GAAL;AACIA,UAAAA,iBAAiB,GAAG,GAApB;AACA;;AACJ,aAAK,GAAL;AACIA,UAAAA,iBAAiB,GAAG,GAApB;AACA;AAbR,OAJ6B,CAoB7B;;;AACA,UAAGI,QAAQ,IAAIA,QAAQ,CAAChB,WAAT,IAAwB,CAAvC,EAAyC;AACrC;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEgB,YAAIkB,QAAQ,GAAGF,QAAQ,CAACJ,iBAAD,CAAvB;AACA,YAAIO,QAAQ,GAAGD,QAAQ,CAACN,iBAAD,CAAvB;;AACA,YAAGM,QAAH,EAAY;AACR,iBAAMA,QAAQ,IAAIA,QAAQ,CAACJ,GAArB,IAA4B,CAACI,QAAQ,CAACE,IAAtC,IAA8CD,QAA9C,IAA0DA,QAAQ,CAACL,GAAnE,IAA0E,CAACK,QAAQ,CAACC,IAA1F,EAA+F;AAC3FH,YAAAA,MAAM,IAAI,CAAV;AACAC,YAAAA,QAAQ,GAAGA,QAAQ,CAACN,iBAAD,CAAnB;AACAO,YAAAA,QAAQ,GAAGA,QAAQ,CAACP,iBAAD,CAAnB;AACH;AACJ;;AAED,YAAIT,MAAM,GAAGF,IAAI,CAACC,KAAL,CAAW,MAAMD,IAAI,CAACE,MAAL,MAAiBO,UAAU,GAAG,CAA9B,IAAmC,CAAzC,CAAX,CAAb;AACAM,QAAAA,QAAQ,CAAChB,WAAT,IAAwBiB,MAAM,GAAGd,MAAjC;AACH,OAzBD,CA0BA;AA1BA,WA2BK,IAAGa,QAAQ,KAAK,IAAhB,EACL;AACI,YAAIE,QAAQ,GAAGL,WAAf;AACA,YAAIM,QAAQ,GAAGD,QAAQ,CAACN,iBAAD,CAAvB;;AACA,YAAGM,QAAH,EAAY;AACR,iBAAMA,QAAQ,IAAIA,QAAQ,CAACJ,GAArB,IAA4B,CAACI,QAAQ,CAACE,IAAtC,IAA8CD,QAA9C,IAA0DA,QAAQ,CAACL,GAAnE,IAA0E,CAACK,QAAQ,CAACC,IAA1F,EAA+F;AAC3FH,YAAAA,MAAM,IAAI,CAAV;AACAC,YAAAA,QAAQ,GAAGA,QAAQ,CAACN,iBAAD,CAAnB;AACAO,YAAAA,QAAQ,GAAGA,QAAQ,CAACP,iBAAD,CAAnB;AACH;AACJ;;AACD,YAAGO,QAAQ,IAAIA,QAAQ,CAACnB,WAAT,IAAwB,CAAvC,EACA;AACImB,UAAAA,QAAQ,CAACnB,WAAT,IAAwBiB,MAAxB;AACH;AACJ;AACJ;AACJ,GAnED,CAqEA;AArEA,OAsEK,IAAGJ,WAAW,CAACT,KAAf,EACL;AACI,SAAI,IAAIW,SAAR,IAAqBJ,UAArB,EACA;AACI,UAAIK,QAAQ,GAAGH,WAAW,CAACE,SAAD,CAA1B;AACA,UAAIE,MAAM,GAAG,CAAb;;AAEA,cAAOF,SAAP;AAEI,aAAK,GAAL;AACIH,UAAAA,iBAAiB,GAAG,GAApB;AACA;;AACJ,aAAK,GAAL;AACIA,UAAAA,iBAAiB,GAAG,GAApB;AACA;;AACJ,aAAK,GAAL;AACIA,UAAAA,iBAAiB,GAAG,GAApB;AACA;;AACJ,aAAK,GAAL;AACIA,UAAAA,iBAAiB,GAAG,GAApB;AACA;AAbR;AAgBA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEY,UAAII,QAAQ,IAAIA,QAAQ,CAACF,GAArB,IAA4B,CAACE,QAAQ,CAACI,IAA1C,EACA;AACI,YAAIF,QAAQ,GAAGF,QAAf;;AACA,eAAME,QAAQ,IAAIA,QAAQ,CAACJ,GAArB,IAA4B,CAACI,QAAQ,CAACE,IAA5C,EACA;AACIH,UAAAA,MAAM,IAAI,CAAV;AACAC,UAAAA,QAAQ,GAAGA,QAAQ,CAACH,SAAD,CAAnB;AACH;;AACD,YAAGG,QAAQ,IAAIA,QAAQ,CAAClB,WAAT,IAAwB,CAAvC,EACA;AACIkB,UAAAA,QAAQ,CAAClB,WAAT,IAAwBiB,MAAxB;AACH;AACJ;AACD;AACZ;AACA;AACA;AAhBY,WAiBK,IAAGJ,WAAW,CAACE,SAAD,CAAX,IAA0BF,WAAW,CAACE,SAAD,CAAX,CAAuBK,IAAjD,IAAyDP,WAAW,CAACD,iBAAD,CAApE,KAA4F,CAACC,WAAW,CAACD,iBAAD,CAAX,CAA+BR,KAAhC,IAAyC,CAACS,WAAW,CAACD,iBAAD,CAAX,CAA+BE,GAArK,CAAH,EACL;AACI,aAAI,IAAIhB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,GAAnB,EAAwBA,CAAC,EAAzB,EAA4B;AACxB,cAAGV,WAAW,CAACW,SAAZ,CAAsBD,CAAtB,EAAyBE,WAAzB,GAAuC,CAA1C,EACA;AACIZ,YAAAA,WAAW,CAACW,SAAZ,CAAsBD,CAAtB,EAAyBE,WAAzB,GAAuC,CAAvC;AACH;AACJ;AACJ;AACJ;AACJ;;AAEDK,EAAAA,OAAO,CAACC,GAAR,CAAY,EAAZ;AACH","sourcesContent":["export function AI2(playerState, turn) {\r\n    var pos\r\n    var max = 0\r\n    var max_position\r\n    var table = document.getElementById('Team 1 turn')\r\n    var cells = table.getElementsByClassName('image1')\r\n\r\n    // Pick the cell with highest prob\r\n    for(var i = 0; i < 100; i++) {\r\n        if (max < playerState.positions[i].probability) {\r\n            max = playerState.positions[i].probability\r\n            max_position = i\r\n        }\r\n    }\r\n\r\n    // If there is no such cell\r\n    if(max === 0)\r\n    {\r\n        // Randomly pick one\r\n        if(turn == \"Team 2 turn\")\r\n        {\r\n            do {\r\n                pos = Math.floor(Math.random() * 100)\r\n            } while (playerState.positions[pos].fired)\r\n            max_position = pos\r\n        }\r\n        \r\n    }\r\n    console.log('AI team 2 ' + max_position)\r\n\r\n    if(max_position >= 0) {\r\n        cells[max_position].click()\r\n    }\r\n\r\n    playerState.positions[max_position].probability = -1\r\n    calculateNextPos(playerState, max_position)\r\n}\r\n\r\nfunction calculateNextPos(playerState, current_position) {\r\n    var randomness = 2\r\n    var directions = { 'w': null, 'n': null, 'e': null, 's': null };\r\n    var oppositeDirection\r\n    var currentCell = playerState.positions[current_position]\r\n\r\n    // If click on ship\r\n    if(currentCell.hit) {\r\n        // Calculate adjacent cell's probability\r\n        for(var direction in directions) {\r\n            var adjacent = currentCell[direction]\r\n            var streak = 1\r\n\r\n            switch(direction)\r\n            {\r\n                case 'w':\r\n                    oppositeDirection = 'e'\r\n                    break\r\n                case 'e':\r\n                    oppositeDirection = 'w'\r\n                    break\r\n                case 'n':\r\n                    oppositeDirection = 's'\r\n                    break\r\n                case 's':\r\n                    oppositeDirection = 'n'\r\n                    break\r\n            }\r\n\r\n            // If the adjacent cell has never been picked\r\n            if(adjacent && adjacent.probability >= 0){\r\n                /*\r\n                Check the next 2 cells with same alignment\r\n                    → If both of them is hit but still not sunk \r\n                        → likely to be the same ship\r\n                            → should pick in the same alignment → more likely to hit\r\n                                → give more probability to adjacent cell\r\n\r\n                  [ ] [ ] [ ]\r\n                  [X] [X] [ ] ← Should pick here\r\n                  [ ] [ ] [ ]\r\n                \r\n                */ \r\n                var checker1 = adjacent[oppositeDirection]\r\n                var checker2 = checker1[oppositeDirection]\r\n                if(checker1){\r\n                    while(checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk){\r\n                        streak += 1\r\n                        checker1 = checker1[oppositeDirection]\r\n                        checker2 = checker2[oppositeDirection]\r\n                    }\r\n                }\r\n\r\n                var random = Math.floor(50 * (Math.random() * (randomness - 1) + 1))\r\n                adjacent.probability += streak * random\r\n            }\r\n            // If the adjacent cell is out of map and the next 2 cell with same alignment is hit and not sunk, the next pick should be the first unpicked cell on the opposite side\r\n            else if(adjacent === null)\r\n            {\r\n                var checker1 = currentCell\r\n                var checker2 = checker1[oppositeDirection]\r\n                if(checker1){\r\n                    while(checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk){\r\n                        streak += 1\r\n                        checker1 = checker1[oppositeDirection]\r\n                        checker2 = checker2[oppositeDirection]\r\n                    }\r\n                }\r\n                if(checker2 && checker2.probability >= 0)\r\n                {\r\n                    checker2.probability *= streak\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // If not click on ship\r\n    else if(currentCell.fired)\r\n    {\r\n        for(var direction in directions)\r\n        {\r\n            var adjacent = currentCell[direction]\r\n            var streak = 1\r\n\r\n            switch(direction)\r\n            {\r\n                case 'w':\r\n                    oppositeDirection = 'e'\r\n                    break\r\n                case 'e':\r\n                    oppositeDirection = 'w'\r\n                    break\r\n                case 'n':\r\n                    oppositeDirection = 's'\r\n                    break\r\n                case 's':\r\n                    oppositeDirection = 'n'\r\n                    break\r\n            }\r\n\r\n            /*\r\n            If adjacent cell is not sunk\r\n                → the other part of the ship must be on the other side\r\n                    -> give the other side unpicked cell (that isn't out of the map) the highest probability\r\n\r\n                                       [ ] [ ] [ ] [ ]\r\n                 Ship should be here → [ ] [X] [X] [M] ← Miss the ship here\r\n                                       [ ] [ ] [ ] [ ]\r\n            */\r\n            if (adjacent && adjacent.hit && !adjacent.sunk)\r\n            {\r\n                var checker1 = adjacent\r\n                while(checker1 && checker1.hit && !checker1.sunk)\r\n                {\r\n                    streak += 1\r\n                    checker1 = checker1[direction]\r\n                }\r\n                if(checker1 && checker1.probability >= 0)\r\n                {\r\n                    checker1.probability *= streak\r\n                }\r\n            }\r\n            /*\r\n            But if it sunk\r\n                -> We should try pick randomly more than pick next to the sunk ship because the ship more likely to spread out more than stick together\r\n            */\r\n            else if(currentCell[direction] && currentCell[direction].sunk && currentCell[oppositeDirection] && (!currentCell[oppositeDirection].fired || !currentCell[oppositeDirection].hit))\r\n            {\r\n                for(var i = 0; i < 100; i++){\r\n                    if(playerState.positions[i].probability > 0)\r\n                    {\r\n                        playerState.positions[i].probability = 0\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    console.log(\"\")\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}