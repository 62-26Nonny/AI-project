{"ast":null,"code":"export function AI(playerState) {\n  var pos;\n  var max = 0;\n  var max_position;\n  var table = document.getElementById('gurumi');\n  var cells = table.getElementsByClassName('image1'); // Pick the cell with highest prob\n\n  for (var i = 0; i < 100; i++) {\n    if (max < playerState.positions[i].probability) {\n      max = playerState.positions[i].probability;\n      max_position = i;\n    }\n  } // If there is no such cell\n\n\n  if (max === 0) {\n    // Randomly pick one\n    do {\n      pos = Math.floor(Math.random() * 100);\n    } while (playerState.positions[pos].fired);\n\n    max_position = pos;\n  }\n\n  if (max_position >= 0) {\n    cells[max_position].click();\n  }\n\n  playerState.positions[max_position].probability = -1;\n  calculateNextPos(playerState, max_position);\n}\n_c = AI;\n\nfunction calculateNextPos(playerState, current_position) {\n  var randomness = 2;\n  var directions = {\n    'w': null,\n    'n': null,\n    'e': null,\n    's': null\n  };\n  var oppositeDirection;\n  var flag = 0;\n  var currentCell = playerState.positions[current_position]; // If click on ship\n\n  if (currentCell.hit) {\n    // Calculate adjacent cell's probability\n    for (var direction in directions) {\n      var adjacent = currentCell[direction];\n      var streak = 1;\n\n      switch (direction) {\n        case 'w':\n          oppositeDirection = 'e';\n          break;\n\n        case 'e':\n          oppositeDirection = 'w';\n          break;\n\n        case 'n':\n          oppositeDirection = 's';\n          break;\n\n        case 's':\n          oppositeDirection = 'n';\n          break;\n      } // If the adjacent cell has never been picked\n\n\n      if (adjacent && adjacent.probability >= 0) {\n        /*\r\n        Check the next 2 cells with same alignment\r\n            → If both of them is hit but still not sunk \r\n                → likely to be the same ship\r\n                    → should pick in the same alignment → more likely to hit\r\n                        → give more probability to adjacent cell\r\n            [ ] [ ] [ ]\r\n          [X] [X] [ ] ← Should pick here\r\n          [ ] [ ] [ ]\r\n        \r\n        */\n        var checker1 = adjacent[oppositeDirection];\n        var checker2 = checker1[oppositeDirection];\n\n        if (checker1) {\n          while (checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk) {\n            streak += 1;\n            checker1 = checker1[oppositeDirection];\n            checker2 = checker2[oppositeDirection];\n          }\n        }\n\n        var random = Math.floor(50 * (Math.random() * (randomness - 1) + 1));\n        adjacent.probability += streak * random;\n      } // If the adjacent cell is out of map and the next 2 cell with same alignment is hit and not sunk, the next pick should be the first unpicked cell on the opposite side\n      else if (adjacent === null) {\n        var checker1 = currentCell;\n        var checker2 = checker1[oppositeDirection];\n\n        if (checker1) {\n          while (checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk) {\n            streak += 1;\n            checker1 = checker1[oppositeDirection];\n            checker2 = checker2[oppositeDirection];\n          }\n        }\n\n        checker1.probability *= streak;\n      }\n    }\n  } // If not click on ship\n  else if (currentCell.fired) {\n    for (var direction in directions) {\n      var adjacent = currentCell[direction];\n      var streak = 1;\n\n      switch (direction) {\n        case 'w':\n          oppositeDirection = 'e';\n          break;\n\n        case 'e':\n          oppositeDirection = 'w';\n          break;\n\n        case 'n':\n          oppositeDirection = 's';\n          break;\n\n        case 's':\n          oppositeDirection = 'n';\n          break;\n      }\n      /*\r\n      If adjacent cell is not sunk\r\n          → the other part of the ship must be on the other side\r\n              -> give the other side unpicked cell the highest probability\r\n                                   [ ] [ ] [ ] [ ]\r\n           Ship should be here → [ ] [X] [X] [M] ← Miss the ship here\r\n                                 [ ] [ ] [ ] [ ]\r\n      */\n\n\n      if (adjacent && adjacent.hit && !adjacent.sunk) {\n        var checker1 = adjacent;\n\n        while (checker1 && checker1.hit && !checker1.sunk) {\n          streak += 1;\n          checker1 = checker1[direction];\n        }\n\n        if (checker1) {\n          checker1.probability *= streak;\n        }\n      }\n      /*\r\n      But if it sunk\r\n          -> We should try pick randomly more than pick next to the sunk ship because the ship more likely to spread out more than stick together\r\n      */\n      else if (currentCell[direction] && currentCell[direction].sunk && currentCell[oppositeDirection] && (!currentCell[oppositeDirection].fired || !currentCell[oppositeDirection].hit)) {\n        for (var i = 0; i < 100; i++) {\n          if (playerState.positions[i].probability > 0) {\n            playerState.positions[i].probability = 0;\n          }\n        }\n      }\n    }\n  } // Can be used as turn counter ← Might not need\n  // At first, use as a way to tell the flow of correct picking so that it still go in that flow. But it doesn't do much so it might need to be delete later\n\n\n  for (var i = 0; i < 100; i++) {\n    if (playerState.positions[i].probability < 0) {\n      playerState.positions[i].probability -= 1;\n    }\n  }\n\n  console.log(\"\");\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"AI\");","map":{"version":3,"sources":["F:/Code/Project/AI-project/battleship/src/AI/AI_team2.js"],"names":["AI","playerState","pos","max","max_position","table","document","getElementById","cells","getElementsByClassName","i","positions","probability","Math","floor","random","fired","click","calculateNextPos","current_position","randomness","directions","oppositeDirection","flag","currentCell","hit","direction","adjacent","streak","checker1","checker2","sunk","console","log"],"mappings":"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","sourcesContent":["export function AI(playerState) {\r\n    var pos\r\n    var max = 0\r\n    var max_position\r\n    var table = document.getElementById('gurumi')\r\n    var cells = table.getElementsByClassName('image1')\r\n\r\n    // Pick the cell with highest prob\r\n    for(var i = 0; i < 100; i++) {\r\n        if (max < playerState.positions[i].probability) {\r\n            max = playerState.positions[i].probability\r\n            max_position = i\r\n        }\r\n    }\r\n\r\n    // If there is no such cell\r\n    if(max === 0)\r\n    {\r\n        // Randomly pick one\r\n        do {\r\n            pos = Math.floor(Math.random() * 100)\r\n        } while (playerState.positions[pos].fired)\r\n        max_position = pos\r\n    }\r\n\r\n    if(max_position >= 0) {\r\n        cells[max_position].click()\r\n    }\r\n\r\n    playerState.positions[max_position].probability = -1\r\n    calculateNextPos(playerState, max_position)\r\n}\r\n\r\nfunction calculateNextPos(playerState, current_position) {\r\n    var randomness = 2\r\n    var directions = { 'w': null, 'n': null, 'e': null, 's': null };\r\n    var oppositeDirection\r\n    var flag = 0\r\n    var currentCell = playerState.positions[current_position]\r\n\r\n    // If click on ship\r\n    if(currentCell.hit) {\r\n        // Calculate adjacent cell's probability\r\n        for(var direction in directions) {\r\n            var adjacent = currentCell[direction]\r\n            var streak = 1\r\n\r\n            switch(direction)\r\n            {\r\n                case 'w':\r\n                    oppositeDirection = 'e'\r\n                    break\r\n                case 'e':\r\n                    oppositeDirection = 'w'\r\n                    break\r\n                case 'n':\r\n                    oppositeDirection = 's'\r\n                    break\r\n                case 's':\r\n                    oppositeDirection = 'n'\r\n                    break\r\n            }\r\n\r\n            // If the adjacent cell has never been picked\r\n            if(adjacent && adjacent.probability >= 0){\r\n                /*\r\n                Check the next 2 cells with same alignment\r\n                    → If both of them is hit but still not sunk \r\n                        → likely to be the same ship\r\n                            → should pick in the same alignment → more likely to hit\r\n                                → give more probability to adjacent cell\r\n\r\n                  [ ] [ ] [ ]\r\n                  [X] [X] [ ] ← Should pick here\r\n                  [ ] [ ] [ ]\r\n                \r\n                */ \r\n                var checker1 = adjacent[oppositeDirection]\r\n                var checker2 = checker1[oppositeDirection]\r\n                if(checker1){\r\n                    while(checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk){\r\n                        streak += 1\r\n                        checker1 = checker1[oppositeDirection]\r\n                        checker2 = checker2[oppositeDirection]\r\n                    }\r\n                }\r\n\r\n                var random = Math.floor(50 * (Math.random() * (randomness - 1) + 1))\r\n                adjacent.probability += streak * random\r\n            }\r\n            // If the adjacent cell is out of map and the next 2 cell with same alignment is hit and not sunk, the next pick should be the first unpicked cell on the opposite side\r\n            else if(adjacent === null)\r\n            {\r\n                var checker1 = currentCell\r\n                var checker2 = checker1[oppositeDirection]\r\n                if(checker1){\r\n                    while(checker1 && checker1.hit && !checker1.sunk && checker2 && checker2.hit && !checker2.sunk){\r\n                        streak += 1\r\n                        checker1 = checker1[oppositeDirection]\r\n                        checker2 = checker2[oppositeDirection]\r\n                    }\r\n                }\r\n                checker1.probability *= streak\r\n            }\r\n        }\r\n    }\r\n\r\n    // If not click on ship\r\n    else if(currentCell.fired)\r\n    {\r\n        for(var direction in directions)\r\n        {\r\n            var adjacent = currentCell[direction]\r\n            var streak = 1\r\n\r\n            switch(direction)\r\n            {\r\n                case 'w':\r\n                    oppositeDirection = 'e'\r\n                    break\r\n                case 'e':\r\n                    oppositeDirection = 'w'\r\n                    break\r\n                case 'n':\r\n                    oppositeDirection = 's'\r\n                    break\r\n                case 's':\r\n                    oppositeDirection = 'n'\r\n                    break\r\n            }\r\n\r\n            /*\r\n            If adjacent cell is not sunk\r\n                → the other part of the ship must be on the other side\r\n                    -> give the other side unpicked cell the highest probability\r\n\r\n                                       [ ] [ ] [ ] [ ]\r\n                 Ship should be here → [ ] [X] [X] [M] ← Miss the ship here\r\n                                       [ ] [ ] [ ] [ ]\r\n            */\r\n            if (adjacent && adjacent.hit && !adjacent.sunk)\r\n            {\r\n                var checker1 = adjacent\r\n                while(checker1 && checker1.hit && !checker1.sunk)\r\n                {\r\n                    streak += 1\r\n                    checker1 = checker1[direction]\r\n                }\r\n                if(checker1)\r\n                {\r\n                    checker1.probability *= streak\r\n                }\r\n            }\r\n            /*\r\n            But if it sunk\r\n                -> We should try pick randomly more than pick next to the sunk ship because the ship more likely to spread out more than stick together\r\n            */\r\n            else if(currentCell[direction] && currentCell[direction].sunk && currentCell[oppositeDirection] && (!currentCell[oppositeDirection].fired || !currentCell[oppositeDirection].hit))\r\n            {\r\n                for(var i = 0; i < 100; i++){\r\n                    if(playerState.positions[i].probability > 0)\r\n                    {\r\n                        playerState.positions[i].probability = 0\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Can be used as turn counter ← Might not need\r\n    // At first, use as a way to tell the flow of correct picking so that it still go in that flow. But it doesn't do much so it might need to be delete later\r\n    for(var i = 0; i < 100; i++)\r\n    {\r\n        if(playerState.positions[i].probability < 0)\r\n        {\r\n            playerState.positions[i].probability -= 1\r\n        }\r\n    }\r\n\r\n    console.log(\"\")\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}